<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chaos Typing Portal â€” Canvas Symbols</title>
<style>
  :root{
    --bg1: #07021a;
    --bg2: #1b1740;
    --accent1: #9ecbff;
    --accent2: #c19bff;
    --accent3: #86ffd9;
  }
  html,body{
    height:100%;
    margin:0;
    font-family:"Courier New", monospace;
    background: linear-gradient(180deg,var(--bg1),var(--bg2));
    color:#fff;
    overflow:hidden;
  }
  canvas { 
    position:fixed; 
    inset:0; 
    width:100%; 
    height:100%; 
    display:block; 
    z-index:0; 
    pointer-events:none; 
  }
  #ui {
    position: fixed;
    z-index: 1000;
    left: 12px;
    top: 12px;
    display:flex;
    gap:8px;
    align-items:center;
    pointer-events: auto;
  }
  .btn {
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.08);
    color: #fff;
    padding: 6px 10px;
    border-radius: 10px;
    text-decoration: none;
    font-size: 13px;
    cursor:pointer;
    user-select:none;
    backdrop-filter: blur(4px);
    transition: all 0.15s;
  }
  .btn:hover { 
    transform: translateY(-1px); 
    background: rgba(255,255,255,0.08); 
  }
  #hint {
    font-size: 13px;
    opacity:0.95;
    color: #dfe6ff;
    padding: 6px 10px;
    border-radius: 8px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border: 1px solid rgba(255,255,255,0.03);
  }
  #madeby {
    position: fixed;
    left:12px;
    bottom:12px;
    z-index:1000;
    color: rgba(255,255,255,0.7);
    font-size: 12px;
    background: rgba(0,0,0,0.18);
    padding:4px 8px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.03);
    pointer-events:auto;
  }
  #nav {
    position: fixed;
    right: 12px;
    top: 12px;
    z-index:1000;
    display:flex;
    flex-direction: column;
    gap: 6px;
  }
  #nav a {
    display: inline-block;
    margin: 0;
    padding: 0.4em 1em;
    border: 1px solid #e07a5f;
    border-radius: 6px;
    background: #fff5e6;
    color: #e07a5f;
    text-decoration: none;
    font-weight: bold;
    font-size: 13px;
    transition: all 0.2s;
  }
  #nav a:hover {
    background: #e07a5f;
    color: #fff5e6;
  }
</style>
</head>
<body>

<div id="ui">
  <button id="muteBtn" class="btn">ðŸ”Š Sound (M)</button>
  <div id="hint">Press any key â€” symbols spawn at your cursor.âœ¨</div>
</div>

<div id="nav">
  <a href="index.html">Home</a>
  <a href="gamesmenu.html">Games Menu</a>
</div>

<div id="madeby">Chaos Typing Portal â€” Canvas Symbols</div>

<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
  }
  addEventListener('resize', resize);
  resize();

  let mouse = { x: canvas.width/2, y: canvas.height/2, inside: false };
  addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; mouse.inside = true; });
  addEventListener('mouseout', ()=> mouse.inside = false);

  // Audio
  let audioCtx = null;
  let soundOn = true;
  const muteBtn = document.getElementById('muteBtn');
  function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  function playChime() {
    if (!soundOn) return;
    initAudio();
    const now = audioCtx.currentTime;
    const o1 = audioCtx.createOscillator();
    const o2 = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const bq = audioCtx.createBiquadFilter();
    o1.type = 'sine'; o2.type = 'sine';
    const base = 420 + Math.random()*260;
    o1.frequency.setValueAtTime(base, now);
    o2.frequency.setValueAtTime(base * (Math.random()*0.04 + 1.01), now);
    o1.detune.value = (Math.random()-0.5)*10;
    o2.detune.value = (Math.random()-0.5)*10;
    bq.type = 'lowpass'; bq.frequency.value = 2400;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.12, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.7 + Math.random()*0.5);
    o1.connect(bq); o2.connect(bq); bq.connect(g); g.connect(audioCtx.destination);
    o1.start(now); o2.start(now);
    o1.stop(now + 1.1 + Math.random()*0.6);
    o2.stop(now + 1.1 + Math.random()*0.6);
  }
  function setSound(on) {
    soundOn = !!on;
    muteBtn.textContent = soundOn ? 'ðŸ”Š Sound (M)' : 'ðŸ”‡ Muted (M)';
  }
  muteBtn.addEventListener('click', ()=> setSound(!soundOn));
  addEventListener('keydown', e => { if (e.key.toLowerCase() === 'm') setSound(!soundOn); });

  // Background stars & mist
  const stars = [];
  for (let i=0;i<160;i++){
    stars.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, r: Math.random()*1.6 + 0.4, baseAlpha: 0.2 + Math.random()*0.8, tw: Math.random()*0.04 + 0.005, phase: Math.random()*Math.PI*2 });
  }
  const mistLayers = [];
  for (let L=0; L<3; L++){
    mistLayers.push({ x: Math.random()*canvas.width*2 - canvas.width, y: Math.random()*canvas.height*0.4, sx: 700 + Math.random()*900, sy: 160 + Math.random()*240, a: 0.05 + L*0.03, speed: 0.02 + L*0.02, hueOff: L*20 });
  }

  // Symbols
  const glyphs = ['âœ¦','âœ§','âœ¶','âœº','âœ¹','âœµ','â˜…','â˜†','âœ·','âœ¸','âœ½','â‚','âœ´'];
  const palettes = ['#9ecbff','#c19bff','#86ffd9','#ffd9a8','#b5c2ff','#9be6ff'];
  const symbols = [];
  const particles = [];

  function rand(a,b){
    if (Array.isArray(a)) return a[Math.floor(Math.random()*a.length)];
    if (b===undefined) return a;
    return a + Math.random() * (b - a);
  }
  function makeSymbol(x,y){
    const baseTypeRand = Math.random();
    let type = 'circle';
    if (baseTypeRand < 0.25) type = 'triangle';
    else if (baseTypeRand < 0.5) type = 'square';
    else if (baseTypeRand < 0.75) type = 'star';
    else type = 'glyph';
    const color = rand(palettes);
    const size = rand(18, 72);
    const angle = Math.random()*Math.PI*2;
    const speed = rand(10, 120) / 60;
    const angleDir = Math.random()*Math.PI*2;
    const vx = Math.cos(angleDir) * speed;
    const vy = Math.sin(angleDir) * speed - rand(0.1, 0.7);
    const lifetime = rand(2.2, 4.5);
    const birth = performance.now() / 1000;
    const glyph = rand(glyphs);
    return { x, y, vx, vy, angle, spin: (Math.random()-0.5)*0.08, color, size, type, glyph, lifetime, birth, alpha:0 };
  }

  function spawnParticles(x,y,count,color){
    for(let i=0;i<count;i++){
      const ang = Math.random()*Math.PI*2;
      const speed = 0.6 + Math.random()*2.6;
      particles.push({ x, y, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, life: 0.45 + Math.random()*0.8, age:0, r: Math.random()*4 + 1, color });
    }
  }

  addEventListener('keydown', e => {
    const spawn = mouse.inside ? { x: mouse.x, y: mouse.y } : { x: canvas.width/2, y: canvas.height/2 };
    const count = Math.random() < 0.14 ? rand(2,4)|0 : 1;
    for(let i=0;i<count;i++){
      const s = makeSymbol(spawn.x + rand(-28,28), spawn.y + rand(-28,28));
      symbols.push(s);
      spawnParticles(s.x, s.y, 6, s.color);
    }
    playChime();
    if(symbols.length > 140) symbols.splice(0, symbols.length - 140);
  });

  function drawGlowCircle(x,y,r,color,alpha=1){
    const grad = ctx.createRadialGradient(x,y,r*0.2,x,y,r);
    grad.addColorStop(0, `rgba(255,255,255,${0.9*alpha})`);
    grad.addColorStop(1, color);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
  function drawTriangle(cx,cy,r,color,alpha=1){
    ctx.save(); ctx.beginPath(); ctx.translate(cx,cy);
    ctx.moveTo(0,-r); ctx.lineTo(r*0.866, r*0.5); ctx.lineTo(-r*0.866, r*0.5); ctx.closePath();
    ctx.fillStyle = color; ctx.globalAlpha = alpha; ctx.fill();
    ctx.restore(); ctx.globalAlpha = 1;
  }
  function drawStar(cx, cy, spikes, outerRadius, innerRadius, color, alpha=1){
    ctx.save(); ctx.beginPath(); ctx.translate(cx, cy);
    let rot = Math.PI / 2 * 3; const step = Math.PI / spikes;
    for (let i = 0; i < spikes; i++){
      const x = Math.cos(rot) * outerRadius;
      const y = Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += step;
      const x2 = Math.cos(rot) * innerRadius;
      const y2 = Math.sin(rot) * innerRadius;
      ctx.lineTo(x2, y2);
      rot += step;
    }
    ctx.closePath(); ctx.fillStyle=color; ctx.globalAlpha=alpha; ctx.fill(); ctx.restore(); ctx.globalAlpha=1;
  }

  let last = performance.now();
  function loop(now){
    const dt = (now - last)/1000;
    last = now;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#07102b'); g.addColorStop(0.5, '#0e1840'); g.addColorStop(1, '#050017');
    ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

    for(const m of mistLayers){
      m.x += m.speed * (0.6 + Math.sin(now/3000 + m.hueOff)*0.5);
      if(m.x > canvas.width + m.sx) m.x = -m.sx;
      ctx.save(); ctx.globalAlpha = m.a;
      const mg = ctx.createRadialGradient(m.x,m.y,0,m.x,m.y,m.sx);
      mg.addColorStop(0, `rgba(150,130,255,0.18)`);
      mg.addColorStop(1, `rgba(5,4,12,0)`);
      ctx.fillStyle = mg; ctx.beginPath(); ctx.ellipse(m.x,m.y,m.sx,m.sy,0,0,Math.PI*2); ctx.fill(); ctx.restore();
    }

    for(const s of stars){
      const tw = Math.sin(now/1000 * (1 + s.tw) + s.phase) * 0.5 + 0.5;
      const alpha = Math.max(0.15, Math.min(1, s.baseAlpha * (0.6 + tw*0.8)));
      ctx.globalAlpha=alpha; ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    }

    for(let i = symbols.length-1;i>=0;i--){
      const s=symbols[i]; const age=(now/1000)-s.birth; const lifeRatio=age/s.lifetime;
      if(lifeRatio>=1){ spawnParticles(s.x,s.y,Math.max(6,Math.round(s.size/12)),s.color); symbols.splice(i,1); continue;}
      s.vx *= 0.996; s.vy *= 0.996;
      s.x += s.vx*(60*dt); s.y += s.vy*(60*dt); s.angle += s.spin*(60*dt);
      const fadeIn=Math.min(0.2,s.lifetime*0.12); s.alpha = (age<fadeIn)? age/fadeIn : Math.max(0,1-(lifeRatio*lifeRatio));
      ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.angle);
      const drawAlpha=Math.min(1,s.alpha);
      if(s.type==='circle'||s.type==='square'){ drawGlowCircle(0,0,s.size*0.9,s.color,0.28*drawAlpha); ctx.globalAlpha=drawAlpha; ctx.fillStyle=s.color;
        if(s.type==='circle'){ ctx.beginPath(); ctx.arc(0,0,s.size*0.55,0,Math.PI*2); ctx.fill(); } else { ctx.fillRect(-s.size*0.6,-s.size*0.6,s.size*1.2,s.size*1.2);}
        ctx.globalAlpha=1;
      } else if(s.type==='triangle'){ drawGlowCircle(0,0,s.size*0.9,s.color,0.22*drawAlpha); drawTriangle(0,0,s.size*0.7,s.color,drawAlpha);
      } else if(s.type==='star'){ drawStar(0,0,5,s.size*0.9,s.size*0.45,s.color,drawAlpha);
      } else { drawGlowCircle(0,0,s.size*0.9,s.color,0.26*drawAlpha); ctx.fillStyle="#fff"; ctx.font=`${Math.round(s.size*0.9)}px serif`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.globalAlpha=drawAlpha; ctx.fillText(s.glyph,0,0); ctx.globalAlpha=1;}
      ctx.restore();
    }

    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i]; p.vx*=0.98;p.vy*=0.98;p.vy+=0.01;p.x+=p.vx*(60*dt);p.y+=p.vy*(60*dt);p.age+=dt;
      const t=1-(p.age/p.life);
      if(t<=0){particles.splice(i,1);continue;}
      drawGlowCircle(p.x,p.y,p.r*(0.6+t*0.8),p.color,Math.max(0.06,t));
    }

    if(Math.random()<0.008){ const cx = canvas.width*0.2 + Math.random()*canvas.width*0.6; const cy = canvas.height*0.2 + Math.random()*canvas.height*0.6; spawnParticles(cx,cy,2+Math.round(Math.random()*4),rand(palettes));}

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
  setInterval(()=>{ if(symbols.length>160) symbols.splice(0,symbols.length-120); if(particles.length>1200) particles.splice(0,800); },1500);
  for(let i=0;i<6;i++){ const x=canvas.width*0.3+Math.random()*canvas.width*0.4; const y=canvas.height*0.35+Math.random()*canvas.height*0.3; symbols.push(makeSymbol(x,y)); }
})();
</script>
</body>
</html
